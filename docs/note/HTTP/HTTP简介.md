# HTTP简介
## HTTP请求模型
![](/img/http/httpMode.png "")
http请求分为客户端和服务端，动作为请求和响应，并且成对出现。  
发起请求的为客户端，响应请求的为服务端，跟是否为服务端语言无关。
比如nodejs可以作为BFF架构的中间层，它既响应浏览器端发送的http请求，又请求另一个后端接口，
既是客户端又是服务端。
## 浏览器行为与HTTP协议
![](/img/http/fromReqToRes.png "")
处理流程：
1. 输入网址并回车
2. 解析域名（使用DNS协议）
3. 浏览器发送HTTP请求（HTTP协议）
4. 服务器处理请求（HTTP协议）
5. 服务器返回HTML响应（HTTP协议）
6. 浏览器处理HTML页面
7. 继续请求其他资源
```sh
# linux或Mac环境
traceroute www.baidu.com
# Windows
tracert www.baidu.com
```
执行此行命令，显示 IP 信息包至某个网络主机的路由。相当于改造过的ping命令。  
详细流程：
1. 用户在浏览器输入谷歌网址，然后浏览器收到命令，经内部处理后，首先要上互联网，即跨过内网和外网之间的设备，
如果可以跨过，说明网络是通的。
2. 如果网络是通的，则进行DNS解析。为什么要解析？因为网址是个字符串，是让人来识别的，而机器只识别IP地址，
DNS解析就是把网址转化成对应的IP地址。（一般一个域名对应一个IP，如果是cdn，一个域名可能对应多个IP；如果多个域名对应
一个IP，则说明一台主机上运行了多个网站，在Apache或者nginx上配置了虚拟网站。）
3. 从DNS服务器上查找到域名对应的IP后，浏览器就知道去访问哪一台服务器了。然后浏览器开始发送HTTP请求。
4. 服务器收到请求后，根据服务器的功能做出对应的响应，比如查找并返回静态资源，或者去其他服务器请求数据，再返回。图片上示例就是一个get请求，需要返回谷歌首页。
5. 服务器返回谷歌首页的HTML。返回的路径和请求的路径不一定相同，具体原因稍后解释。
6. 浏览器解析服务器返回的HTML。
7. 解析的HTML里面一般还包含其他资源请求，比如js、css、img等，因此需要继续发送请求。
8. 最后浏览器进行渲染，用户就看到了谷歌的界面。
  
思考：请求和响应的路径为何不一定相同？  
答：局域网的设备，发送请求到互联网上，中间可能要经过很多路由器，这些路由器对用户来说是透明的，即感觉不到的。
网络上有很多路由器，这些设备都是互相连接在一起的，形成了网络。
当客户端发送出一个数据包时，它需要先查一个列表，即路由表，里面记录了到达终点前需要经过的设备。
为什么不直接一条路走到头？这是为了网络的健壮性，当其中某个路由器出故障，还有其他路径可选，每走一个路由，在网络协议上叫一跳。
路由表是一个策略，是人为制定的，受物理距离、传输时间、成本等影响，会按照最佳路径制定，而不是最短路径。
## 什么是HTTP协议
- HTTP是超文本传输协议，从www服务器传输到本地浏览器的一种传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于
HTTP协议进行传输的。
- HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(response)进行约束和规范。
### 版本
HTTP/1.1比HTTP/1.0多了长连接，HTTP/2自带加密模块。  
HTTPS属于另一种协议，在HTTP/1.1基础上多了加密模块。  
HTTP/3之前的都是基于TCP协议的，HTTP/3基于UDP协议，谷歌基于UDP封装成了QUIC协议。
## 了解TCP/IP协议栈
![](/img/http/tcpIp.png "")
TCP/IP协议栈分为两个版本，上图左侧为ISO/OSI协议，国际标准化组织（ISO）制定的，右侧为传统的TCP/IP协议，事实上的，五层协议。ISO组织认为五层协议有缺陷，所以细化成了七层协议。
1. 应用层   
为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等. 
2. 传输层   
为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性。 
该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP)。
- TCP：面向连接的，提供稳定可靠的传输手段，类似于打电话，双方必须确认建立起连接才开始通话
- UDP：面向无连接的，不保证数据传输的可靠性，类似于广播，消息发出去了，但是对方不一定收到
两种协议不分优劣，只是适用场景不同。
3. 网络层   
主要解决主机到主机的通信问题。IP协议是网际互联层最重要的协议。 
4. 网络接口层   
负责监视数据在主机和网络之间的交换。细分为
- 数据链路层：负责把比特流转成光电信号或无线电信号，让硬件去承载。
- 物理层：纯硬件，比如网线，水晶头，WIFI的频率是5G还是2.4G。  
总结：应用层、传输层、网络层，属于软件层面，网络接口层属于硬件层面，数据传输，一般情况下，只能相邻层传输，不能跨层。
## HTTP在TCP/IP协议栈中的位置
![](/img/http/httpPosition.png "")
HTTP在应用层，HTTPS比HTTP多了加密协议TLS(前身为SSL)和SSL。
TLS、SSL不是完整的一层，它只是HTTP处理机制中的一个小步骤，属于嵌入HTTP的一个模块。
- 目前普遍应用版本HTTP 1.1 
- 正在逐步向HTTP 2迁移 
- HTTP默认端口号为80 
- HTTPS默认端口号为443
## HTTP的工作过程
一次HTTP操作称为一个事务，其工作过程可分为四步： 
1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 
2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号，
后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功
或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户
来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。
## 请求与响应
- HTTP请求组成：请求行、消息报头、请求正文。 
- HTTP响应组成：状态行、消息报头、响应正文。 
- 请求行组成：以一个方法符号开头，后面跟着请求的URI和协议的版本。 
- 状态行组成：服务器HTTP协议的版本，服务器发回的响应状态代码和状态代码的文本描述。

注意：get请求没有请求正文，post、put等方法才有。
请求或响应的数据实际上都是一体的，没有分开，只是浏览器解析成了三部分。
### 请求
![](/img/http/req.png "")
![](/img/http/reqData.png "")
### 响应
![](/img/http/response.png "")
### 请求方法
- GET： 请求获取Request-URI所标识的资源 
- POST： 在Request-URI所标识的资源后附加新的数据 
- HEAD： 请求获取由Request-URI所标识的资源的响应消息报头 
- PUT： 请求服务器存储一个资源，并用Request-URI作为其标识 
- DELETE： 请求服务器删除Request-URI所标识的资源 
- TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断 
- CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
- OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求

RESTful协议规定包含GET POST PUT DELETE 这几种请求方法，不过一般只用前两种。  
trace类似于ping。
## HTTP状态码
作用：反映HTTP协议的处理状态。  
状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 
- 1xx：指示信息--表示请求已接收，继续处理 
- 2xx：成功--表示请求已被成功接收、理解、接受 
- 3xx：重定向--要完成请求必须进行更进一步的操作 
- 4xx：客户端错误--请求有语法错误或请求无法实现 
- 5xx：服务器端错误--服务器未能实现合法的请求

参考[状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100)

例子：  
101：表示服务器应客户端升级协议的请求（Upgrade (en-US)请求头）正在切换协议。  
200：OK 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。
304：未改变，说明无需再次传输请求的内容，也就是说可以使用缓存的内容。  
429：Too Many Requests 表示在一定的时间内用户发送了太多的请求。  
502：Bad Gateway 是一种HTTP协议的服务器端错误状态代码，它表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。
## 常用的请求报头
Connection:keep-alive 表示长连接
- 短连接：在HTTP/1.0中，默认使用的是短连接。每发起一个请求时都会创建一个新的连接，并在收到应答时立即关闭。这个简单的模型对性能有先天的限制：打开每一个 TCP 连接都是相当耗费资源的操作。客户端和服务器端之间需要交换好些个消息。当请求发起时，网络延迟和带宽都会对性能造成影响。现代浏览器往往要发起很多次请求(十几个或者更多)才能拿到所需的完整信息，证明了这个早期模型的效率低下。
- 长连接：在HTTP/1.1中，默认使用的是长连接。它会保持连接去完成多次连续的请求，减少了不断重新打开连接的时间。  
参考[HTTP/1.x 的连接管理](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x)

Referer:请求来源，请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。

Accept:用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，Accept：text/html。

Accept-Charset:用于指定客户端接受的字符集。

Accept-Encoding：类似于Accept，但是它是用于指定可接受的内容编码。 将客户端能够理解的内容编码方式——通常是某种压缩算法——进行通知（给服务端）。通过内容协商的方式，服务端会选择一个客户端提议的方式，使用并在响应头 Content-Encoding 中通知客户端该选择。

Accept-Language:类似于Accept，但是它是用于指定一种自然语言。 

Authorization:主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服
务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进
行验证。 

Host:主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，发
送请求时，该报头域是必需的。 一般给反向代理用。

User-Agent:允许客户端将它的操作系统、浏览器和其它属性告诉服务器。
## 常用的响应报头
用于服务器传递自身信息的响应。

Location：首部指定的是需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义。

Server：表示当前使用的是哪一种HTTP服务器
## 常用的实体报头
用来描述消息体内容。实体报头既可用于请求也可用于响应中。

Content-Encoding:被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的
附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码
机制。 HTTP/1.1中，响应头不会被压缩，只压缩响应体。

Content-Language:描述了资源所用的自然语言。

Content-Length:用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 

Content-Type:用语指明发送给接收者的实体正文的媒体类型。 

Last-Modified:用于指示资源的最后修改日期和时间。 

Expires:给出响应过期的日期和时间。

## cookies与session
- Cookies是保存在客户端的小段文本，随客户端点每一个请求发送该url
下的所有cookies到服务器端。 
- Session则保存在服务器端，通过唯一的值sessionID来区别每一个用
户。SessionID随每个连接请求发送到服务器，服务器根据sessionID来识
别客户端，再通过session 的key获取session值。
### Cookie的使用
与Cookie相关的HTTP扩展头 
- Cookie：客户端将服务器设置的Cookie返回到服务器; 
- Set-Cookie：服务器向客户端设置Cookie;
- 服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie
头中发送给服务器。从而实现会话的保持。
### Session的使用
- 使用Cookie来实现
- 使用URL回显来实现